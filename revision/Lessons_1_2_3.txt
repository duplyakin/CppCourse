1. Вывести строку "Hello, World" в стандартный поток вывода.

2. Ввести число int N со стандартного потока ввода.

3. Реализовать функцию factorial(int N).

4. Ввести строку с пробельными символами со стандартного потока ввода.

5. Реализовать оператор + для конкатенации строки и int числа.

6. Написать функцию, принимающую 1 аргумент и "возвращающую" 2 других значения.

7. Написать функцию, копирующую два char-массива. Какие опасные места в реализации можно указать?

8. Написать функцию, вычисляющую среднее значение в векторе int чисел.

9. Реализовать класс Point, представляющущю собой точку в 2D-пространстве. Определить конструкторы.

10. В классе Point определить операторы присваивания: =, +=, -=, а также бинарные операторы +, -.

11. Реализовать функцию, вычисляющую расстояние между 2-мя точками Point.

12. Написать программу, в которой последовательно считывать строки из stdin и для каждой опеределить, является ли она палиндромом.

13. Написать программу, которая для каждого слова из текстового файла подсчитывала бы количество его вхождений.

14. Вычислить a^n без использования функций стандартной библиотеки.

15. Написать программу, считывающую строки, состоящие из цифр от 0 до 9 из stdin, и затем отсортировать все эти строки в числовом порядке. Преобразовывать строки в числа нельзя. Строки могут быть очень длинными (т.е. число может не поместиться в тип unsigned long long).

16. Реализовать функции strlen, strcat, strrev, strcmp. Написать юнит-тест, проверяющий корректность на случайных наборах данных.

17. Реализовать функцию int atoi(char*).

18. Написать функцию double solve(double a, double b, F func) нахождения корня монотонной на отрезке [a, b) функции F методом деления пополам. Как должен быть определен тип F?

19. Написать функцию copy_if(), которая принимает пару итераторов исходной последовательности, итератор на начало выходной последовательности (его же и возвращает), а также функцию-предикат bool predicate(T item). В выходную последовательность должны копироваться только те элементы входной последовательности, которые удовлетворяют этому предикату. Тип T - шаблонный.

20. Реализовать класс Array целых чисел и продемонстрировать глубокое копирование.

21. В классе Array реализовать операторы: [], <<, и функции begin(), end(). Продемонстрировать работу класса с алгоритмами std::copy() и copy_if().

22. Прочитать текстовый файл по словам и поместить их в std::vector, а затем вывести содержимое этого контейнера в stdout.

23. Для класса SortedLinkedList реализовать класс-итератор. Написать методы итератора в соответствии с его категорией.

24. Реализовать алгоритм бинарного поиска в последовательности элементов типа T, заданной парой итераторов.

25. Написать пользовательскую операцию сравнения (или operator ()) над объектом класса Point и отсортировать std::vector<Point>.

26. Вычислить количество сравнений, которое осуществляет алгоритм std::sort() во время сортировки некоторой последовательности.

27. Вычислить количество сравнений для других алгоритмов сортировки: insertion_sort, mergesort, quicksort.

28. Написать класс Vector3D для представления вектора в 3-хмерном пространстве. Определить операторы: +, -, +=, -=, =, []

29. Определить функции для вычисления модуля вектора, скалярного и векторного произведений.

30. Реализовать строковые методы: strcmp, strlen, strcat, strcpy.

31. Реализовать класс-оболочку для работы с файлом: открывать файл следует в конструкторе, а закрывать - в деструкторе (идиома RAII).

32. Реализовать класс-оболочку для работы с динамической памятью: выделять память следует в конструкторе, а удалять - в деструкторе (Smart Poiner).

33. Определить новый тип: указатель на функцию, которая возвращает bool, а принимает два объекта Node.

34. Написать, как выглядит прототип функции printf().

35. Написать объявление класса Matrix и методы: конструктор, оператор << для инициализации объекта класса элементами, записанными через запятую.

36. Написать функцию: char* itoa(size_t value, char* out, size_t base);

37. Считать текстовый файл построчно. Вычислить количество строк и слов в каждой строке.

38. Реализовать шаблонный алгоритм count_if.

39. Реализовать шаблонный алгоритм merge.

40. Реализовать шаблонный алгоритм max_element.

41. Реализовать шаблонные функторы: equal_to, not_equal_to, greater, less, plus, minus, multiplies, divides, modulus.

42. Написать класс MemoryManager, который хранит набор страниц памяти (класс Page) размером 4096 байт в некотором диапазоне адресов. Реализовать метод getPage(int address), которая возвращает страницу памяти, содержающую указанный адрес.

43. Задача на кучу: http://www.problems.ru/view_problem_details_new.php?id=98676

44. Сделать одну из функций сортировки (insertion_sort, mergesort, quicksort) шаблонной, принимающец пару итераторов и функтор сравнения.

45. Реализовать класс "хеш-таблица" строковых значений и функцию хеширования. Разрешать коллизии методом цепочек. Сравнить производительность при добавлении N элементов и чтении по сравнению со стандартным классом std::unordered_set.

46. Переделать BST<T> в карту "ключ-знвчение" BST<K, V>, где K - тип ключа, V - тип значения. Все операции производятся по ключу.

47. Реализовать шаблонные классы: пара Pair<K, V>, Triplet<K, V, W>, Quartet<K, X, Y, Z>. Каждый следующий класс должен основываться на предыдущем.

48. Написать прототип класса "кортеж": Tuple<V1, V2, V3, ...>.

49. Написать класс-итератор для BST<T> и методы: begin(), end(). С помощью std::copy() вывести дерево в stdout.

50. Написать определение класса-паттерна Singleton: это такой класс, у которого может быть только один объект.

51. Написать функции, вычисляющие: exp, sin. Сравнить точность вычислений на некоторых значениях со стандартными функциями из <cmath>.

52. Измерить время сортировки 1.000.000 целых чисел каждой из функций: insertion_sort, mergesort, quicksort, std::sort().

53. В классе Array реализовать класс-итератор. Какой категории принадлежит этот итератор? Реализовать все методы из этой категории и базовые методы итераторов.

54. Реализовать шаблонную функцию advance(Input iterator, int distance). Функция должна сдвигать данный итератор на distance позиций вперед или назад в зависимости от знака. Функция должна уметь работать с итераторами любой категории, и использовать +, - для Rdm, и ++, -- для остальных категорий.

55. Реализовать шаблонную специализацию std::iterator_traits<> для класса-итератора в классе Array. Продемонстрировать работу итератора с алгоритмами: std::copy(), std::sort(), std::transform(), std::accumulate() и функцией advance().

