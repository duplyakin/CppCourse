Тест по материалам Lesson 1:
----------------------------------------------------------------------------------------------
1. Что такое область видимости переменной и чем она определяется? Что такое "время жизни" переменной? 
Какая область видимости (и какое "время жизни") у переменных 
(global_variable, local_1, local_2, index, value, argc, argv) в следующем примере:

int global_variable = 1;

int main(int argc, char** argv) {
  int local_1 = 0;
  {
    int local_2 = 1;
  }
  for (int index = 0; index < 5; ++index) {
    int value = i * 2;
    local_1 += value;
  }

  return 0;
}

----------------------------------------------------------------------------------------------
2. Ссылка появилась в С++ и является "синонимом" указателю. Ссылка является "псевдонимом" переменной:

int variable = 5;
int& reference = variable;

Раз ссылка - это "псевдоним" переменной, то у переменной 'variable' стало как будто два разных имени: variable и reference.
По любой из этих двух переменных можно получить значение (число 5 в примере), расположенное в памяти, выделенной под эту
локальную переменную.

Ссылка всегда должна быть инициализирована в точке ее объявления, значением какой-нибудь переменной того же типа (int в примере).
Таким образом, нельзя объявлять неинициализированные ссылки (ошибка компиляции):

int variable = 5;
int& reference;  // ОШИБКА !

Параметры в функции можно передавать "по ссылке" (похоже на передачу "по указателю") - тогда "по значению" будет
передаваться ссылка на внешнюю переменную:

void foo(int& ref);
...

int variable = 5;
int& reference = variable;
foo(variable);
foo(reference);  // то же самое

Когда значение передается по ссылке или по указателю, стандарты кодирования предполагают, что значение внешней
переменной может (или будет) изменено в теле функции. Однако передачу аргументов по ссылке следует избегать, так как
в вызывающей программе будет отсутствовать символ &, как при передаче по указателю, по которому читающий код сразу видит,
что аргумент может изменяться в теле функции (Сравните: functions_8.cpp и functions_9.cpp).

Ссылки будут применяться позже в уроке про Классы (Lesson 3+).

Вопрос: в следующем фрагменте программы компилятор выдаст важное предупреждение. Что не так в программе?

int& calculate(int a, int b) {
  int sum = a + b;
  return sum;
}

int a = 5, b = 7;
int& s = sum(a, b);

----------------------------------------------------------------------------------------------
3. Почему не скомпилируется программа?

void function(double& value) {
  ...
}

function(5.0);

Как исправить?

----------------------------------------------------------------------------------------------
4. В локальном репозитории пользователь переключился на ветку develop и выполняет команду:

git pull origin develop

Что делает эта команда? Что такое origin?

----------------------------------------------------------------------------------------------
5. Что такое staged, unstaged и untracked области в локальном git-репозитории?
Содержимое какой области войдет в следующий коммит, а какой не войдет?

----------------------------------------------------------------------------------------------
6. Чем размер (size) отличается от емкости (capacity) в классе-контейнере std::vector<> ?
Какие функции-члены позволяют выяснить размер и емкость? Зачем вообще нужно понятие емкости,
и что будет, если бы его не было?

----------------------------------------------------------------------------------------------
7. Диапазон значений типа char равен [-128, 127], а диапазон значений типа short равен [-32768, 32767]
Почему правая граница меньше на единицу, чем модуль левой границы? Какие диапазоны имеют типы
unsigned char и unsigned short?

----------------------------------------------------------------------------------------------
8. Что такое "явное" и "неявное" преобразования типов? Какие из нижеследующих выражений содержат
явные или неявные преобразования, и какие типы к каким преобразуются? В каких ситуациях результат будет "плохим"?
Напишите также значения, которые принимают переменные в левой части от оператора присваивания:

char ch = 255;
short sh = 12000;
int pi = 3.14;
char exp = 2.71;
double pid = 3.1415f;
float expf = 2.71828182845904523536f

int a = 98531;
long l = a;

int b = 123456789098765432L;
unsigned char ch = -127;
unsigned short s = -'a';
short s = 'a';
char = '0';
int a = (int) '5';
char ch = static_cast<char>(64);

*********
int foo(int value, double exp) {
  return value * exp;
}

short sh = foo('a', 2.71);
short sh = foo(65537, 3.14);
size_t size = 50 - 70;

----------------------------------------------------------------------------------------------
9. Почему для массивов справедлива запись?

array[5] == 5[array]

----------------------------------------------------------------------------------------------
10. Почему лучше использовать std::vector<> вместо низкоуровневого массива array[]?
Что делать, если Вам в наследство достался старый код, который работает только с массивами,
а Вы используете его в современной программе, где применяется std::vector<>? Как передать
такой вектор в "старую" функцию, принимающую массив и размер массива?

----------------------------------------------------------------------------------------------
11. Что такое реаллокация? Как часто она может происходить, как это влияет на производительность?

----------------------------------------------------------------------------------------------
12. Чему будет равна переменная lhs? Использовать компилятор нельзя!

int lhs = 5, 7, 9;
int lhs = (5, 6), 9;
int lhs = (5, 6), (7, 8, 9)
int lhs = ((5, 6), (7, 8, 9))

----------------------------------------------------------------------------------------------
13. Даны массив и односвязный список, каждый содержит N элементов. Какое время доступа к i-му
элементу имеет каждая из этих структур данных? Тот же вопрос для стека и очереди.

----------------------------------------------------------------------------------------------
14. Какая из структур данных - динамический массив (std::vector<>) или связный список - 
эффективнее (по времени и по памяти) в следующих операциях:

а) добавление элемента в начало
б) добавление элемента в конец
в) добавление элемента в середину
г) сортировка

Дайте асимптотические оценки времени (в терминах О-большое), если в структуре N элементов.

----------------------------------------------------------------------------------------------
15. Что такое "утечка памяти"? Приведите пример утечки памяти при выделении большого массива целых чисел.

----------------------------------------------------------------------------------------------
16. Как объявить новый тип: указатель на функцию, которая принимает int, char и double параметры,
и возвращает два (int и std::vector<>) значения? Как объявить функцию, которая принимает аргумент
такого типа, и как эта функция будет вызываться?

----------------------------------------------------------------------------------------------
17. Элементы прямоугольной матрицы размера NxM (N - число строк, M - число столбцов) хранятся
в массиве double** data. Как инициализировать этот массив случайными значениями? Как недопустить
утечки памяти?

----------------------------------------------------------------------------------------------
18. Дан вектор std::vector<>. Как последовательно в цикле заполнить его N случайными величинами?
Как это можно сделать без цикла, используя синтаксис С++11 - фигурные скобки { }? Тот же вопрос
для обычного низкоуровневого массива. Как получить i-й элемент вектора?

----------------------------------------------------------------------------------------------
19*. Что выведет программа? Использовать компилятор нельзя!

enum Command {
  NONE = -1,
  PUSH = 0,
  POP = 1,
  PRINT = 2,
  EXIT = 3
};

int command = 4;

printf("Before");
switch (command) {
  case NONE:
    printf("none");
    break;
  case PUSH:
    printf("push");
    break;
  case POP:
    printf("pop");
    break;
  case PRINT:
    printf("print");
    break;
  defalut:
  case EXIT:
    printf("exit");
    break;
}
printf("After");

----------------------------------------------------------------------------------------------
20*. Что выведет программа? enum объявлен в предыдущем вопросе. Использовать компилятор нельзя!

command = Command::PUSH;

printf("Before");
switch (command) {
  case NONE: 
    printf("none");
    break;
  case PUSH:
    printf("push");
    command = Command::PRINT;
    break;
  case POP:
    printf("pop");
    break;
  case PRINT:
    printf("print");
    break;
  default:
  case EXIT:
    printf("exit");
    break;
}
printf("After");

