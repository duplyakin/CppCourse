1. Implement other arithmetic operations on complex values:

Use operations_6.cpp and provide other operations:

binary operations: -, *, /, ==, !=
unary operations: -, +, prefix and postfix ++, --
assignment operations: -=, *=, /=

Think carefully, what type return value should have?
What operations should be 'const' and what should not?

Avoid code duplication.

// ----------------------------------------------------------------------------
2. Write unit-test and check correctness of these operations
using std::complex from <complex> header file.
{@see http://en.cppreference.com/w/cpp/numeric/complex }

// ----------------------------------------------------------------------------
3*. Write class Matrix.

Class Matrix represents a square matrix NxN. Store N dynamically in class,
type of elements should be 'double' (but think how to make a design which
allows to change type of elements easily in future).

Provide default ctor, ~dtor, copy ctor (deep copy), and several ctors with parameters:
a) (size_t N, double default_value) - initializes NxN matrix with default_value;
b) (size_t N, double** array) - initializes NxN matrix with values from array[][];

Overload all possible binary operations: +, -, * ;
Provide some overloadings when right-hand-side parameter is a 'double' scalar value;
Also, overload all assigments: +=, -=, *= ;
Overload unary operations: +, - ;
Overload boolean operations: ==, != ;
Overload streaming operations: <<, >> ;
Overload operator [], which allows to take (i, j)-th element like this: matrix[i][j];
Overload operator (), which does the same like this: matrix(i, j);

Provide some member-functions: determinant(), transpose(), inversion(), submatrix(), trace(), diag();
What of these operations should and what should not change the initial matrix?
What arguments should be passed to these functions, what are the types of return values?

Provide begin(), end() and iterator type definition.

Provide member-function minor(size_t row, size_t col) - initializes an adjacent minor (matrix N-1 x N-1) 
from matrix with row-th row and col-th column discarded; Use this member-function, when implementing
determinant() and inverse(). Provide similar ctor(const Matrix& obj, size_t row, size_t col) to initialize an adjacent minor.

Provide global function power() which raises a given matrix into an integer power. If power < 0, make an inversion.

Provide test samples. Do not check bounds of rows and cols in this implementation.

// ----------------------------------------------------------------------------
4* Write class Rational.

Class Rational represents a rational value P/Q, Q != 0.
Overload some ctors and all possible arithmetic operators.
Overload additional compare operators: <, >, <=, >= ;

Provide test samples.

// ----------------------------------------------------------------------------
5** Write class Polynomial.

Class Polynomial represents a polynomial of N-th power with double coefficients.
Overload constructors: default ctor, ~dtor, copy ctor (deep copy), ctor(double[], N);
Overload all possible arithmetic operators and compare operators;
Overload operator () which takes a double x and calculates value of polynomial in x; Use Horner's rule.
Overload operator , "comma", which calculated GCD of two polynomials (what is the type of result?);
Overload operator << and >>; Output should look like: 3x^2 + 5.7x + 11.0 ;

Provide test samples.

